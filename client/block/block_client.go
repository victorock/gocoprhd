package block

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new block API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for block API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
CreateExport creates export

Block export method is use to export one or more volumes to one or more
hosts. This is a required step for a host to be able to access a block
volume, although in some scenarios, additional configurations may be
required. There are three main types of export group to meet the common
use cases:

Create an initiator type export group so that a single host can see one
or more volumes. An example would be an export group for a host boot lun
or a private volume that is meant to be used by only one host. The
assumption is, in this case the user wants the boot or private volume
to be accessed via known initiators. For this type of export, the
request object is expected to have only initiators (i.e. no hosts or
clusters). Further, the initiators are expected to belong to the same
host. While an initiator type export group can belong to only one host,
this does not mean the host can only have the initiator type export
group. A hosts can be part of many export groups of any type. The export
group type {@link ExportGroupType#Initiator} should be specified in the
request for this type of export.

Create an export group so that one or more hosts, which are not part of
a cluster, can access one or more volumes. This is the use case of a
shared data lun. In this case, it is assumed that the user wants all the
hosts initiators that are connected to the storage array (up to the
maximum specified by the virtual pool) to be able to access the volume.
The export group type {@link ExportGroupType#Host} should be specified
in the request for this type of export.

Create an export group so that one or more clusters of hosts can access
one or more volumes. This is the same use case of shared data lun as the
{@link ExportGroupType#Host} use case with the exception that the user
is managing a cluster of hosts as opposed to individual hosts. In this
case, the same assumption about the initiators as in the previous case
is made. The export group type {@link ExportGroupType#Cluster} should be
specified in the request for this type of export.

Note that the above discussion only mentions volumes but mirrors and
snapshots can also be used in export groups.

Once a block export is created, following incremental changes can be
applied to it:
  - add volume or volume snapshot to the shared storage pool
  - remove volume or volume snapshot from the shared storage pool
  - add new server to the cluster by adding initiator from that server
    to the block export - remove visibility of shared storage to a
    server by removing initiators from the block export

Similar to block storage provisioning, block export is also created
within the scope of a varray. Hence, volumes and snapshots being added
to a block export must belong to the same varray. Fibre Channel and
iSCSI initiators must be part of SANs belonging to the same varray as
block export.

For Fibre Channel initiators, SAN zones will also be created when the
export group is created if the networks are discovered and:

at least one of the Network Systems can provision the Vsan or Fabric in
which the each endpoint exists, and the VirtualArray has
"auto_san_zoning" set to true.

The SAN zones each consists of an initiator (from the arguments) and a
storage port that is selected. The number of zones created will be
determined from the number of required initiator/storage-port
communication paths.

*/
func (a *Client) CreateExport(params *CreateExportParams, authInfo runtime.ClientAuthInfoWriter) (*CreateExportAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateExportParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateExport",
		Method:             "POST",
		PathPattern:        "/block/exports.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateExportReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateExportAccepted), nil
}

/*
CreateSnapshotFullCopy creates full copy

Create a full copy as a volume of the specified snapshot.

*/
func (a *Client) CreateSnapshotFullCopy(params *CreateSnapshotFullCopyParams, authInfo runtime.ClientAuthInfoWriter) (*CreateSnapshotFullCopyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateSnapshotFullCopyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateSnapshotFullCopy",
		Method:             "POST",
		PathPattern:        "/block/snapshots/{id}/protection/full-copies.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateSnapshotFullCopyReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateSnapshotFullCopyAccepted), nil
}

/*
CreateVolume creates volume

"The fundamental abstraction in the Block Store is a volume.
A volume is a unit of block storage capacity that has been allocated by
a consumer to a project. This API allows the user to create one or more
volumes. The volumes are created in the same storage pool.
NOTE=This is an asynchronous operation."

*/
func (a *Client) CreateVolume(params *CreateVolumeParams, authInfo runtime.ClientAuthInfoWriter) (*CreateVolumeAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateVolumeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateVolume",
		Method:             "POST",
		PathPattern:        "/block/volumes.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateVolumeReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateVolumeAccepted), nil
}

/*
CreateVolumeFullCopy creates full copy

Create a full copy of the specified volume.

*/
func (a *Client) CreateVolumeFullCopy(params *CreateVolumeFullCopyParams, authInfo runtime.ClientAuthInfoWriter) (*CreateVolumeFullCopyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateVolumeFullCopyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateVolumeFullCopy",
		Method:             "POST",
		PathPattern:        "/block/volumes/{id}/protection/full-copies.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateVolumeFullCopyReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateVolumeFullCopyAccepted), nil
}

/*
CreateVolumeSnapshot creates volume snapshot

A snapshot is a point-in-time copy of a volume. Snapshots are intended
for short-term operational recovery and are typically implemented using
lightweight, fast capabilities native to the underlying storage
platforms. Like a volume, a snapshot can be exported to initiators,
and you can delete it. A snapshots lifetime is tied to the original
volume. When the original volume is deleted all of its snapshots will
also be deleted. A snapshot is associated with the same project as the
original volume. A volume may be restored in place based on a snapshot.
The snapshot must have come from the volume. A new volume may be created
 using a snapshot as a template. See multi-volume consistent snapshots
 for a description of an advanced feature to snapshot multiple volumes
 at once. NOTE: This is an asynchronous operation.

*/
func (a *Client) CreateVolumeSnapshot(params *CreateVolumeSnapshotParams, authInfo runtime.ClientAuthInfoWriter) (*CreateVolumeSnapshotAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateVolumeSnapshotParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateVolumeSnapshot",
		Method:             "POST",
		PathPattern:        "/block/volumes/{id}/protection/snapshots.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateVolumeSnapshotReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateVolumeSnapshotAccepted), nil
}

/*
DeleteExport deletes export group

Deactivate block export. It will be deleted by the garbage collector on
a subsequent iteration

This removes visibility of shared storage in the block export to servers
through initiators in the block export.

If SAN Zones were created as a result of this Export Group (see Export
Group Create), they will be removed if they are not in use by other
Export Groups.

*/
func (a *Client) DeleteExport(params *DeleteExportParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteExportAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteExportParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteExport",
		Method:             "POST",
		PathPattern:        "/block/exports/{id}/deactivate.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteExportReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteExportAccepted), nil
}

/*
DeleteSnapshot deactivates snapshot

Deactivate volume snapshot, this will move the snapshot to a
"marked-for-delete" state. It will be deleted by the garbage collector
on a subsequent iteration If this snapshot was created from a volume
that is part of a consistency group, then all the related snapshots
will be deactivated, as well.

*/
func (a *Client) DeleteSnapshot(params *DeleteSnapshotParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteSnapshotAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteSnapshotParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteSnapshot",
		Method:             "POST",
		PathPattern:        "/block/snapshots/{id}/deactivate.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteSnapshotReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteSnapshotAccepted), nil
}

/*
DeleteVolume deletes volume

Deactivate a volume, this will move the volume to a "marked-for-delete"
state after the deletion happens on the array side. The volume will be
deleted from the database when all references to this volume of type
BlockSnapshot and ExportGroup are deleted. If "?force=true" is added to
the path, it will force the delete of internal volumes that have the
SUPPORTS_FORCE flag. NOTE: This is an asynchronous operation.

*/
func (a *Client) DeleteVolume(params *DeleteVolumeParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteVolumeAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteVolumeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteVolume",
		Method:             "POST",
		PathPattern:        "/block/volumes/{id}/deactivate.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteVolumeReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteVolumeAccepted), nil
}

/*
ExpandVolume expands volume

"Request to expand volume capacity to the specified size.
NOTE: This is an asynchronous operation."

*/
func (a *Client) ExpandVolume(params *ExpandVolumeParams, authInfo runtime.ClientAuthInfoWriter) (*ExpandVolumeAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExpandVolumeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ExpandVolume",
		Method:             "POST",
		PathPattern:        "/block/volumes/{id}/expand.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ExpandVolumeReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ExpandVolumeAccepted), nil
}

/*
ListSnapshots lists snapshots

Retrieve all ids of this type of resources.

*/
func (a *Client) ListSnapshots(params *ListSnapshotsParams, authInfo runtime.ClientAuthInfoWriter) (*ListSnapshotsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListSnapshotsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListSnapshots",
		Method:             "GET",
		PathPattern:        "/block/snapshots/bulk.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListSnapshotsReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListSnapshotsOK), nil
}

/*
ListVolumeExports lists volume exports

"Return all the export information related to this volume.
This will be in the form of a list of initiator / target pairs for all the
initiators that have been paired with a target storage port."

*/
func (a *Client) ListVolumeExports(params *ListVolumeExportsParams, authInfo runtime.ClientAuthInfoWriter) (*ListVolumeExportsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListVolumeExportsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListVolumeExports",
		Method:             "GET",
		PathPattern:        "/block/volumes/{id}/exports.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListVolumeExportsReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListVolumeExportsOK), nil
}

/*
ListVolumeSearch searches for item with name

Search resources by name, tag, project or additional parameters
(for example, wwn or initiator_port etc.)

*/
func (a *Client) ListVolumeSearch(params *ListVolumeSearchParams, authInfo runtime.ClientAuthInfoWriter) (*ListVolumeSearchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListVolumeSearchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListVolumeSearch",
		Method:             "GET",
		PathPattern:        "/block/volumes/search.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListVolumeSearchReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListVolumeSearchOK), nil
}

/*
ListVolumeSnapshots lists volume snapshot

List volume snapshots

*/
func (a *Client) ListVolumeSnapshots(params *ListVolumeSnapshotsParams, authInfo runtime.ClientAuthInfoWriter) (*ListVolumeSnapshotsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListVolumeSnapshotsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListVolumeSnapshots",
		Method:             "GET",
		PathPattern:        "/block/volumes/{id}/protection/snapshots.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListVolumeSnapshotsReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListVolumeSnapshotsOK), nil
}

/*
ListVolumes lists volumes

Retrieve all ids of this type of resources.

*/
func (a *Client) ListVolumes(params *ListVolumesParams, authInfo runtime.ClientAuthInfoWriter) (*ListVolumesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListVolumesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListVolumes",
		Method:             "GET",
		PathPattern:        "/block/volumes/bulk.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListVolumesReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListVolumesOK), nil
}

/*
ShowExport shows export group

Get block export details - the list of volumes and snapshots and the
list of SCSI initiators that the shared storage is exported to.

*/
func (a *Client) ShowExport(params *ShowExportParams, authInfo runtime.ClientAuthInfoWriter) (*ShowExportOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewShowExportParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ShowExport",
		Method:             "GET",
		PathPattern:        "/block/exports/{id}.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ShowExportReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ShowExportOK), nil
}

/*
ShowSnapshot shows snapshot

Show snapshot details.

*/
func (a *Client) ShowSnapshot(params *ShowSnapshotParams, authInfo runtime.ClientAuthInfoWriter) (*ShowSnapshotOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewShowSnapshotParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ShowSnapshot",
		Method:             "GET",
		PathPattern:        "/block/snapshots/{id}.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ShowSnapshotReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ShowSnapshotOK), nil
}

/*
ShowVolume shows volume

Show the details of a specific volume

*/
func (a *Client) ShowVolume(params *ShowVolumeParams, authInfo runtime.ClientAuthInfoWriter) (*ShowVolumeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewShowVolumeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ShowVolume",
		Method:             "GET",
		PathPattern:        "/block/volumes/{id}.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ShowVolumeReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ShowVolumeOK), nil
}

/*
UpdateExport updates export group

Update an export group which includes:
    Add/Remove block objects (volumes, mirrors and snapshots)
    Add/remove clusters
    Add/remove hosts
    Add/remove initiators

Depending on the export group type (Initiator, Host or Cluster), the
request is restricted to enforce the same rules as
{@link #createExportGroup(ExportCreateParam)}:
    For initiator type groups, only initiators are accepted in the
    request. Further the initiators must be in the same host as the
    existing initiators.

    For host type groups, only hosts and initiators that belong to
    existing hosts will be accepted.

    For cluster type groups, only clusters, hosts and initiators will
    be accepted. Hosts and initiators must belong to existing clusters
    and hosts.

Note: The export group name, project and varray can not be modified.

*/
func (a *Client) UpdateExport(params *UpdateExportParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateExportAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateExportParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateExport",
		Method:             "PUT",
		PathPattern:        "/block/exports/{id}.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateExportReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateExportAccepted), nil
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
