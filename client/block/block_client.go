package block

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new block API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for block API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
CreateSnapshotFullCopy creates full copy

Create a full copy as a volume of the specified snapshot.

*/
func (a *Client) CreateSnapshotFullCopy(params *CreateSnapshotFullCopyParams, authInfo runtime.ClientAuthInfoWriter) (*CreateSnapshotFullCopyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateSnapshotFullCopyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateSnapshotFullCopy",
		Method:             "POST",
		PathPattern:        "/block/snapshots/{id}/protection/full-copies.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateSnapshotFullCopyReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateSnapshotFullCopyAccepted), nil
}

/*
CreateVolume creates volume

"The fundamental abstraction in the Block Store is a volume.
A volume is a unit of block storage capacity that has been allocated by
a consumer to a project. This API allows the user to create one or more
volumes. The volumes are created in the same storage pool.
NOTE=This is an asynchronous operation."

*/
func (a *Client) CreateVolume(params *CreateVolumeParams, authInfo runtime.ClientAuthInfoWriter) (*CreateVolumeAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateVolumeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateVolume",
		Method:             "POST",
		PathPattern:        "/block/volumes.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateVolumeReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateVolumeAccepted), nil
}

/*
CreateVolumeFullCopy creates full copy

Create a full copy of the specified volume.

*/
func (a *Client) CreateVolumeFullCopy(params *CreateVolumeFullCopyParams, authInfo runtime.ClientAuthInfoWriter) (*CreateVolumeFullCopyAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateVolumeFullCopyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateVolumeFullCopy",
		Method:             "POST",
		PathPattern:        "/block/volumes/{id}/protection/full-copies.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateVolumeFullCopyReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateVolumeFullCopyAccepted), nil
}

/*
CreateVolumeSnapshot creates volume snapshot

A snapshot is a point-in-time copy of a volume. Snapshots are intended
for short-term operational recovery and are typically implemented using
lightweight, fast capabilities native to the underlying storage
platforms. Like a volume, a snapshot can be exported to initiators,
and you can delete it. A snapshots lifetime is tied to the original
volume. When the original volume is deleted all of its snapshots will
also be deleted. A snapshot is associated with the same project as the
original volume. A volume may be restored in place based on a snapshot.
The snapshot must have come from the volume. A new volume may be created
 using a snapshot as a template. See multi-volume consistent snapshots
 for a description of an advanced feature to snapshot multiple volumes
 at once. NOTE: This is an asynchronous operation.

*/
func (a *Client) CreateVolumeSnapshot(params *CreateVolumeSnapshotParams, authInfo runtime.ClientAuthInfoWriter) (*CreateVolumeSnapshotAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateVolumeSnapshotParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateVolumeSnapshot",
		Method:             "POST",
		PathPattern:        "/block/volumes/{id}/protection/snapshots.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateVolumeSnapshotReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateVolumeSnapshotAccepted), nil
}

/*
DeleteExport deletes export group

Deactivate block export. It will be deleted by the garbage collector on
a subsequent iteration

This removes visibility of shared storage in the block export to servers
through initiators in the block export.

If SAN Zones were created as a result of this Export Group (see Export
Group Create), they will be removed if they are not in use by other
Export Groups.

*/
func (a *Client) DeleteExport(params *DeleteExportParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteExportAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteExportParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteExport",
		Method:             "POST",
		PathPattern:        "/block/exports/{id}/deactivate.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteExportReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteExportAccepted), nil
}

/*
DeleteSnapshot deactivates snapshot

Deactivate volume snapshot, this will move the snapshot to a
"marked-for-delete" state. It will be deleted by the garbage collector
on a subsequent iteration If this snapshot was created from a volume
that is part of a consistency group, then all the related snapshots
will be deactivated, as well.

*/
func (a *Client) DeleteSnapshot(params *DeleteSnapshotParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteSnapshotAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteSnapshotParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteSnapshot",
		Method:             "POST",
		PathPattern:        "/block/snapshots/{id}/deactivate.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteSnapshotReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteSnapshotAccepted), nil
}

/*
DeleteVolume deletes volume

Deactivate a volume, this will move the volume to a "marked-for-delete"
state after the deletion happens on the array side. The volume will be
deleted from the database when all references to this volume of type
BlockSnapshot and ExportGroup are deleted. If "?force=true" is added to
the path, it will force the delete of internal volumes that have the
SUPPORTS_FORCE flag. NOTE: This is an asynchronous operation.

*/
func (a *Client) DeleteVolume(params *DeleteVolumeParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteVolumeAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteVolumeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteVolume",
		Method:             "POST",
		PathPattern:        "/block/volumes/{id}/deactivate.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteVolumeReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteVolumeAccepted), nil
}

/*
ExpandVolume expands volume

"Request to expand volume capacity to the specified size.
NOTE: This is an asynchronous operation."

*/
func (a *Client) ExpandVolume(params *ExpandVolumeParams, authInfo runtime.ClientAuthInfoWriter) (*ExpandVolumeAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExpandVolumeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ExpandVolume",
		Method:             "POST",
		PathPattern:        "/block/volumes/{id}/expand.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ExpandVolumeReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ExpandVolumeAccepted), nil
}

/*
ListSnapshots lists snapshots

Retrieve all ids of this type of resources.

*/
func (a *Client) ListSnapshots(params *ListSnapshotsParams, authInfo runtime.ClientAuthInfoWriter) (*ListSnapshotsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListSnapshotsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListSnapshots",
		Method:             "GET",
		PathPattern:        "/block/snapshots/bulk.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListSnapshotsReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListSnapshotsOK), nil
}

/*
ListVolumeExports lists volume exports

"Return all the export information related to this volume.
This will be in the form of a list of initiator / target pairs for all the
initiators that have been paired with a target storage port."

*/
func (a *Client) ListVolumeExports(params *ListVolumeExportsParams, authInfo runtime.ClientAuthInfoWriter) (*ListVolumeExportsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListVolumeExportsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListVolumeExports",
		Method:             "GET",
		PathPattern:        "/block/volumes/{id}/exports.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListVolumeExportsReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListVolumeExportsOK), nil
}

/*
ListVolumeSearch searches for item with name

Search resources by name, tag, project or additional parameters
(for example, wwn or initiator_port etc.)

*/
func (a *Client) ListVolumeSearch(params *ListVolumeSearchParams, authInfo runtime.ClientAuthInfoWriter) (*ListVolumeSearchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListVolumeSearchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListVolumeSearch",
		Method:             "GET",
		PathPattern:        "/block/volumes/search.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListVolumeSearchReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListVolumeSearchOK), nil
}

/*
ListVolumeSnapshots lists volume snapshot

List volume snapshots

*/
func (a *Client) ListVolumeSnapshots(params *ListVolumeSnapshotsParams, authInfo runtime.ClientAuthInfoWriter) (*ListVolumeSnapshotsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListVolumeSnapshotsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListVolumeSnapshots",
		Method:             "GET",
		PathPattern:        "/block/volumes/{id}/protection/snapshots.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListVolumeSnapshotsReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListVolumeSnapshotsOK), nil
}

/*
ListVolumes lists volumes

Retrieve all ids of this type of resources.

*/
func (a *Client) ListVolumes(params *ListVolumesParams, authInfo runtime.ClientAuthInfoWriter) (*ListVolumesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListVolumesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListVolumes",
		Method:             "GET",
		PathPattern:        "/block/volumes/bulk.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListVolumesReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListVolumesOK), nil
}

/*
ShowExport shows export group

Get block export details - the list of volumes and snapshots and the
list of SCSI initiators that the shared storage is exported to.

*/
func (a *Client) ShowExport(params *ShowExportParams, authInfo runtime.ClientAuthInfoWriter) (*ShowExportOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewShowExportParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ShowExport",
		Method:             "GET",
		PathPattern:        "/block/exports/{id}.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ShowExportReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ShowExportOK), nil
}

/*
ShowSnapshot shows snapshot

Show snapshot details.

*/
func (a *Client) ShowSnapshot(params *ShowSnapshotParams, authInfo runtime.ClientAuthInfoWriter) (*ShowSnapshotOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewShowSnapshotParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ShowSnapshot",
		Method:             "GET",
		PathPattern:        "/block/snapshots/{id}.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ShowSnapshotReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ShowSnapshotOK), nil
}

/*
ShowVolume shows volume

Show the details of a specific volume

*/
func (a *Client) ShowVolume(params *ShowVolumeParams, authInfo runtime.ClientAuthInfoWriter) (*ShowVolumeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewShowVolumeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ShowVolume",
		Method:             "GET",
		PathPattern:        "/block/volumes/{id}.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ShowVolumeReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ShowVolumeOK), nil
}

/*
UpdateExport updates export group

Update an export group which includes:
    Add/Remove block objects (volumes, mirrors and snapshots)
    Add/remove clusters
    Add/remove hosts
    Add/remove initiators

Depending on the export group type (Initiator, Host or Cluster), the
request is restricted to enforce the same rules as
{@link #createExportGroup(ExportCreateParam)}:
    For initiator type groups, only initiators are accepted in the
    request. Further the initiators must be in the same host as the
    existing initiators.

    For host type groups, only hosts and initiators that belong to
    existing hosts will be accepted.

    For cluster type groups, only clusters, hosts and initiators will
    be accepted. Hosts and initiators must belong to existing clusters
    and hosts.

Note: The export group name, project and varray can not be modified.

*/
func (a *Client) UpdateExport(params *UpdateExportParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateExportAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateExportParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateExport",
		Method:             "PUT",
		PathPattern:        "/block/exports/{id}.json",
		ProducesMediaTypes: []string{"application/json", "application/x-gzip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateExportReader{formats: a.formats},
		AuthInfo:           authInfo,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateExportAccepted), nil
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
